name: Deploy ‚Ä¢ VPS via password (Production)

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag d'image √† d√©ployer (ex: latest, 1.3, <sha court>)"
        required: true
        default: "latest"

concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  SERVICE: api
  IMAGE: kysaymeric/pavillon-les-lys
  DEPLOY_DIR: /home/sk_aymeric/pavillon-lys-api
  ENV_URL: http://51.254.33.99:3000 # remplace par ton domaine si tu en as un

jobs:
  deploy:
    runs-on: ubuntu-latest

    # ‚úÖ Badge "Deployed to production" + historique c√¥t√© GitHub
    environment:
      name: production
      url: ${{ env.ENV_URL }}

    permissions:
      contents: read
      deployments: write # n√©cessaire pour cr√©er/mettre √† jour un "Deployment" GitHub

    steps:
      - name: Create GitHub Deployment
        id: create_deployment
        uses: actions/github-script@v7
        with:
          script: |
            const res = await github.request('POST /repos/{owner}/{repo}/deployments', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.sha,
              environment: 'production',
              auto_merge: false,
              required_contexts: []
            });
            core.setOutput('deployment_id', res.data.id);

      - name: SSH & deploy (password auth, bash + debug)
        id: ssh_deploy
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_PASSWORD }}
          port: ${{ secrets.VPS_SSH_PORT }}
          command_timeout: 30m
          script_stop: true
          script: |
            bash -lc '
              set -euxo pipefail
              set -x
              SERVICE="${{ env.SERVICE }}"
              DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
              IMAGE_TAG="${{ github.event.inputs.tag }}"
              PASS="${{ secrets.VPS_PASSWORD }}"

              echo "== Check directory =="
              test -d "$DEPLOY_DIR" || { echo "‚ùå Directory $DEPLOY_DIR does not exist"; exit 10; }
              ls -ld "$DEPLOY_DIR"
              cd "$DEPLOY_DIR"
              echo "‚úÖ Working directory: $(pwd)"

              echo "== Check Docker & Compose =="
              DOCKER_NEEDS_SUDO=false
              if docker --version >/dev/null 2>&1; then docker --version; else
                echo "$PASS" | sudo -S docker --version >/dev/null 2>&1 || { echo "‚ùå Docker not available"; exit 11; }
                DOCKER_NEEDS_SUDO=true
                echo "$PASS" | sudo -S docker --version
              fi

              COMPOSE_NEEDS_SUDO=false
              if docker compose version >/dev/null 2>&1; then
                docker compose version
              elif command -v docker-compose >/dev/null 2>&1; then
                docker-compose version
              elif echo "$PASS" | sudo -S docker compose version >/dev/null 2>&1; then
                COMPOSE_NEEDS_SUDO=true
                echo "$PASS" | sudo -S docker compose version
              elif echo "$PASS" | sudo -S docker-compose version >/dev/null 2>&1; then
                COMPOSE_NEEDS_SUDO=true
                echo "$PASS" | sudo -S docker-compose version
              else
                echo "‚ùå Docker Compose not found. Install: sudo apt-get update && sudo apt-get install -y docker-compose-plugin"
                exit 12
              fi

              echo "== Helpers =="
              run_docker() {
                if [ "$DOCKER_NEEDS_SUDO" = true ]; then
                  echo "$PASS" | sudo -S docker "$@"
                else
                  docker "$@"
                fi
              }
              run_compose() {
                if docker compose version >/dev/null 2>&1; then
                  if [ "$COMPOSE_NEEDS_SUDO" = true ]; then
                    echo "$PASS" | sudo -S docker compose "$@"
                  else
                    docker compose "$@"
                  fi
                else
                  if [ "$COMPOSE_NEEDS_SUDO" = true ]; then
                    echo "$PASS" | sudo -S docker-compose "$@"
                  else
                    docker-compose "$@"
                  fi
                fi
              }

              echo "== Docker Hub login (optional) =="
              if [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
                echo "${{ secrets.DOCKERHUB_TOKEN }}" | run_docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin || true
              else
                echo "No Docker Hub credentials provided, skipping login"
              fi

              echo "== Capture pre-deployment image =="
              PRE_IMAGE=$(run_docker ps --filter "name=^/pavillon-api$" --format "{{.Image}}" 2>/dev/null || echo "none")
              echo "PRE_IMAGE=$PRE_IMAGE"

              echo "== Update .env IMAGE_TAG =="
              if [ -f .env ]; then
                if grep -q "^IMAGE_TAG=" .env; then
                  sed -i "s/^IMAGE_TAG=.*/IMAGE_TAG=${IMAGE_TAG}/" .env
                else
                  echo "IMAGE_TAG=${IMAGE_TAG}" >> .env
                fi
              else
                echo "IMAGE_TAG=${IMAGE_TAG}" > .env
              fi
              echo "--- .env ---"; cat .env; echo "-------------"

              echo "== Pull & Deploy service: ${SERVICE} =="
              run_compose pull "${SERVICE}"
              run_compose up -d "${SERVICE}"

              echo "== Capture post-deployment image =="
              sleep 3
              POST_IMAGE=$(run_docker ps --filter "name=^/pavillon-api$" --format "{{.Image}}" 2>/dev/null || echo "none")
              echo "POST_IMAGE=$POST_IMAGE"

              DATE_UTC=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              echo "::notice title=Deployment::${SERVICE} d√©ploy√© avec le tag ${IMAGE_TAG}"
              echo "SERVER=${{ secrets.VPS_HOST }}"
              echo "SERVICE=${SERVICE}"
              echo "TAG=${IMAGE_TAG}"
              echo "PRE_IMAGE=${PRE_IMAGE}"
              echo "POST_IMAGE=${POST_IMAGE}"
              echo "DATE=${DATE_UTC}"
              echo "DEPLOY_DIR=${DEPLOY_DIR}"

              echo "== Cleanup old images =="
              run_docker image prune -f || true

              echo "== Final status =="
              run_docker ps --filter "name=pavillon-api" --format "table {{.Names}}\\t{{.Status}}\\t{{.Image}}" || true
            '

      - name: Publish Job Summary
        run: |
          {
            echo "## üöÄ D√©ploiement ‚Äî Pavillon Les Lys (production)";
            echo "";
            echo "**Tag d√©ploy√© :** \`${{ github.event.inputs.tag }}\`";
            echo "**Service :** \`${{ env.SERVICE }}\`";
            echo "**Serveur :** \`${{ secrets.VPS_HOST }}\`";
            echo "**Dossier de d√©ploiement :** \`${{ env.DEPLOY_DIR }}\`";
            echo "**URL :** ${{ env.ENV_URL }}";
            echo "";
            echo "_Consulte les logs pour voir l'image avant/apr√®s et l'heure UTC._";
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Set Deployment Status (success)
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.request('POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.create_deployment.outputs.deployment_id }},
              state: 'success',
              environment: 'production',
              environment_url: process.env.ENV_URL,
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });

      - name: Set Deployment Status (failure)
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.request('POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses', {
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.create_deployment.outputs.deployment_id }},
              state: 'failure',
              environment: 'production',
              environment_url: process.env.ENV_URL,
              log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            });
